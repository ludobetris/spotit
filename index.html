<!DOCTYPE html>
<html lang="fr">
<head>
    <!-- (En-tête inchangé) -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Carte Mapbox avec Trackers Traccar</title>
    <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet" />
    <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
    <style>
        /* Votre style CSS existant */
        /* ... (Style inchangé) ... */
        
        /* Style pour les marqueurs de beacons */
        .beacon-marker {
            background-color: blue;
            width: 20px;
            height: 20px;
            border-radius: 50%;
        }
    </style>
</head>
<body>
    <!-- (Corps inchangé) -->
    <!-- Modal pour saisir les identifiants -->
    <div id="credentials-modal">
        <form id="credentials-form">
            <h2>Connexion</h2>
            <label for="mapbox-key">Clé API Mapbox :</label>
            <input type="text" id="mapbox-key" required placeholder="Entrez votre clé API Mapbox">
            
            <label for="traccar-username">Nom d'utilisateur Traccar :</label>
            <input type="text" id="traccar-username" required placeholder="Entrez votre nom d'utilisateur">
            
            <label for="traccar-password">Mot de passe Traccar :</label>
            <input type="password" id="traccar-password" required placeholder="Entrez votre mot de passe">
            
            <button type="submit">Se Connecter</button>
        </form>
    </div>

    <!-- Barre de recherche et autres éléments -->
    <!-- ... (Éléments inchangés) ... -->

    <!-- Carte Mapbox -->
    <div id="map"></div>

    <script>
        // Variables globales pour les identifiants
        let MAPBOX_API_KEY = '';
        let TRACCAR_AUTH = '';

        // Variables globales pour la carte
        let map;

        // Variables globales pour stocker les données
        let trackers = [];
        let markers = {};
        let groups = [];
        let groupIdToName = {};

        // Variables pour les beacons
        let beacons = {};
        let beaconMarkers = {};

        // Coordonnées du dépôt
        const depotCoordinates = [7.475422, 46.257917];

        // Autres variables
        let searchMarker = null;
        let routeLayerId = 'tracker-route';
        let routeCoordinates = [];
        let timelineData = [];
        let timelineMarker = null;

        // Références aux éléments DOM
        const searchInput = document.getElementById('search-input');
        const suggestionsList = document.getElementById('suggestions-list');

        // Intervalle de mise à jour
        const UPDATE_INTERVAL = 10000;
        let updateIntervalId = null;

        // Fonction de calcul de distance
        function getDistanceFromLatLonInMeters(lat1, lon1, lat2, lon2) {
            // ... (Fonction inchangée) ...
            const R = 6371e3; // Rayon de la Terre en mètres
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = 
                Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
                Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            const d = R * c;
            return d;
        }

        // Fonction pour obtenir les données de Traccar
        async function getTrackersData() {
            try {
                // 1. Récupération des groupes
                const groupsResponse = await fetch('https://demo2.traccar.org/api/groups', {
                    method: 'GET',
                    headers: {
                        'Authorization': 'Basic ' + TRACCAR_AUTH,
                        'Content-Type': 'application/json'
                    }
                });
                const groupsData = await groupsResponse.json();
                console.log('Groupes reçus:', groupsData);
                groups = groupsData;
                groups.forEach(group => {
                    groupIdToName[group.id] = group.name;
                });

                // 2. Récupération des devices
                const devicesResponse = await fetch('https://demo2.traccar.org/api/devices', {
                    method: 'GET',
                    headers: {
                        'Authorization': 'Basic ' + TRACCAR_AUTH,
                        'Content-Type': 'application/json'
                    }
                });
                const devicesData = await devicesResponse.json();
                console.log('Devices reçus:', devicesData);
                const deviceIdToInfo = {};
                devicesData.forEach(device => {
                    deviceIdToInfo[device.id] = {
                        name: device.name || `Tracker ${device.id}`,
                        group: device.groupId ? groupIdToName[device.groupId] || 'Autre' : 'Autre'
                    };
                });

                // 3. Récupération des positions
                const positionsResponse = await fetch('https://demo2.traccar.org/api/positions', {
                    method: 'GET',
                    headers: {
                        'Authorization': 'Basic ' + TRACCAR_AUTH,
                        'Content-Type': 'application/json'
                    }
                });
                const positionsData = await positionsResponse.json();
                console.log('Positions reçues:', positionsData);

                // 4. Assignation des noms et groupes
                trackers = positionsData.map(position => ({
                    ...position,
                    name: (deviceIdToInfo[position.deviceId] && deviceIdToInfo[position.deviceId].name) || `Tracker ${position.deviceId}`,
                    group: (deviceIdToInfo[position.deviceId] && deviceIdToInfo[position.deviceId].group) || 'Autre',
                    latitude: parseFloat(position.latitude),
                    longitude: parseFloat(position.longitude),
                    time: position.time
                }));

                // Traitement des beacons
                beacons = {}; // Réinitialiser les beacons

                positionsData.forEach(position => {
                    for (let i = 1; i <= 4; i++) {
                        const namespaceKey = `beacon${i}Namespace`;
                        const instanceKey = `beacon${i}Instance`;
                        const rssiKey = `beacon${i}Rssi`;

                        if (position.attributes && position.attributes[namespaceKey] && position.attributes[instanceKey]) {
                            const beaconId = position.attributes[namespaceKey] + position.attributes[instanceKey];

                            // Décaler légèrement la position du beacon pour éviter le chevauchement
                            let offsetLongitude = parseFloat(position.longitude) + (Math.random() - 0.5) * 0.0001;
                            let offsetLatitude = parseFloat(position.latitude) + (Math.random() - 0.5) * 0.0001;

                            if (!beacons[beaconId] || new Date(position.deviceTime) > new Date(beacons[beaconId].lastSeen)) {
                                beacons[beaconId] = {
                                    id: beaconId,
                                    name: `Beacon ${position.attributes[namespaceKey]} ${position.attributes[instanceKey]}`,
                                    latitude: offsetLatitude,
                                    longitude: offsetLongitude,
                                    lastSeen: position.deviceTime,
                                    rssi: position.attributes[rssiKey],
                                    group: 'Beacons'
                                };
                            }
                        }
                    }
                });

                console.log('Beacons détectés:', beacons);

                displayGroupCheckboxes();
                populateTrackerSelect();
                updateMap();
                populateDepotList();
            } catch (error) {
                console.error('Erreur lors de la récupération des données:', error);
                alert('Une erreur est survenue lors de la récupération des données des trackers.');
            }
        }

        // Fonction pour afficher les cases à cocher des groupes
        function displayGroupCheckboxes() {
            const groupList = document.getElementById('group-list');
            groupList.innerHTML = '';

            // Récupérer les groupes uniques des trackers et beacons
            const uniqueGroups = [...new Set([...trackers.map(tracker => tracker.group), ...Object.values(beacons).map(beacon => beacon.group)])].sort();

            uniqueGroups.forEach(groupe => {
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.checked = true;
                checkbox.classList.add('group-checkbox');
                checkbox.dataset.groupe = groupe;
                checkbox.addEventListener('change', updateMap);

                const label = document.createElement('label');
                label.textContent = groupe;
                label.prepend(checkbox);

                groupList.appendChild(label);
            });
        }

        // Fonction pour peupler le sélecteur de trackers
        function populateTrackerSelect() {
            const trackerSelect = document.getElementById('tracker-select');
            trackerSelect.innerHTML = '<option value="">Sélectionner un tracker</option>';

            trackers.forEach(tracker => {
                const option = document.createElement('option');
                option.value = `tracker-${tracker.deviceId}`;
                option.textContent = tracker.name;
                trackerSelect.appendChild(option);
            });

            // Ajouter les beacons au sélecteur
            Object.values(beacons).forEach(beacon => {
                const option = document.createElement('option');
                option.value = `beacon-${beacon.id}`;
                option.textContent = beacon.name;
                trackerSelect.appendChild(option);
            });

            // Écouteur de changement
            trackerSelect.addEventListener('change', (event) => {
                const selectedValue = event.target.value;
                if (!selectedValue) return;

                const [type, id] = selectedValue.includes('-') ? selectedValue.split('-') : ['tracker', selectedValue];

                if (type === 'tracker') {
                    const selectedTracker = trackers.find(tracker => tracker.deviceId == id);

                    if (selectedTracker && selectedTracker.latitude && selectedTracker.longitude) {
                        map.flyTo({ center: [selectedTracker.longitude, selectedTracker.latitude], zoom: 14 });
                        console.log(`Centrage de la carte sur le tracker ${selectedTracker.name || selectedTracker.deviceId}`);
                    }
                } else if (type === 'beacon') {
                    const selectedBeacon = beacons[id];

                    if (selectedBeacon && selectedBeacon.latitude && selectedBeacon.longitude) {
                        map.flyTo({ center: [selectedBeacon.longitude, selectedBeacon.latitude], zoom: 14 });
                        console.log(`Centrage de la carte sur le beacon ${selectedBeacon.name}`);
                    }
                }
            });
        }

        // Fonction pour mettre à jour la carte
        function updateMap() {
            if (!map) {
                console.warn('La carte n\'est pas encore initialisée.');
                return;
            }

            // Retirer les marqueurs existants
            Object.values(markers).forEach(marker => marker.remove());
            markers = {};

            // Retirer les marqueurs de beacons existants
            Object.values(beaconMarkers).forEach(marker => marker.remove());
            beaconMarkers = {};

            // Récupérer les groupes cochés
            const checkedGroups = Array.from(document.querySelectorAll('.group-checkbox:checked'))
                .map(checkbox => checkbox.dataset.groupe);
            console.log('Groupes cochés:', checkedGroups);

            // Afficher les trackers
            trackers.forEach(tracker => {
                const groupe = tracker.group;
                if (checkedGroups.includes(groupe)) {
                    if (typeof tracker.longitude === 'number' && typeof tracker.latitude === 'number') {
                        let marker;
                        if (groupe.toLowerCase() === 'pickups') {
                            const el = document.createElement('img');
                            el.src = 'https://github.com/ludobetris/3d-models/raw/main/pickup.png';
                            el.style.width = '70px';
                            el.style.height = '70px';
                            el.style.objectFit = 'contain';
                            el.style.margin = '0';
                            el.style.padding = '0';

                            marker = new mapboxgl.Marker(el)
                                .setLngLat([tracker.longitude, tracker.latitude])
                                .setPopup(new mapboxgl.Popup().setHTML(`<strong>Nom:</strong> ${tracker.name || "Inconnu"}`))
                                .addTo(map);
                        } else {
                            marker = new mapboxgl.Marker()
                                .setLngLat([tracker.longitude, tracker.latitude])
                                .setPopup(new mapboxgl.Popup().setHTML(`<strong>Nom:</strong> ${tracker.name || "Inconnu"}`))
                                .addTo(map);
                        }
                        markers[tracker.deviceId] = marker;
                        console.log(`Ajout du tracker ${tracker.name || tracker.deviceId} au groupe ${groupe}`);
                    } else {
                        console.warn(`Tracker ${tracker.name || tracker.deviceId} a des coordonnées invalides.`);
                    }
                }
            });

            // Afficher les beacons
            Object.values(beacons).forEach(beacon => {
                const groupe = beacon.group;
                if (checkedGroups.includes(groupe)) {
                    if (typeof beacon.longitude === 'number' && typeof beacon.latitude === 'number') {
                        const el = document.createElement('div');
                        el.className = 'beacon-marker';

                        const marker = new mapboxgl.Marker(el)
                            .setLngLat([beacon.longitude, beacon.latitude])
                            .setPopup(new mapboxgl.Popup().setHTML(`<strong>Nom:</strong> ${beacon.name || "Beacon"}`))
                            .addTo(map);

                        beaconMarkers[beacon.id] = marker;
                        console.log(`Ajout du beacon ${beacon.name} au groupe ${groupe}`);
                    } else {
                        console.warn(`Beacon ${beacon.name} a des coordonnées invalides.`);
                    }
                }
            });
        }

        // Fonction pour peupler la liste du dépôt
        function populateDepotList() {
            const depotList = document.getElementById('depot-list');
            depotList.innerHTML = '';

            function addDepotListItem(item, isBeacon = false) {
                const distance = getDistanceFromLatLonInMeters(
                    depotCoordinates[1],
                    depotCoordinates[0],
                    item.latitude,
                    item.longitude
                );
                console.log(`${item.name}: Distance = ${distance.toFixed(1)}m`);
                if (distance <= 200) {
                    const listItem = document.createElement('li');

                    const itemButton = document.createElement('button');
                    itemButton.textContent = `${item.name} (${distance.toFixed(1)}m)`;
                    itemButton.addEventListener('click', () => {
                        if (item.longitude && item.latitude) {
                            map.flyTo({ center: [item.longitude, item.latitude], zoom: 14 });
                            console.log(`Centrage de la carte sur ${isBeacon ? 'le beacon' : 'le tracker'} ${item.name}`);
                            
                            const marker = isBeacon ? beaconMarkers[item.id] : markers[item.deviceId];
                            if (marker) {
                                marker.togglePopup();
                            }
                        }
                    });

                    listItem.appendChild(itemButton);
                    depotList.appendChild(listItem);
                }
            }

            // Ajouter les trackers
            trackers.forEach(tracker => {
                if (typeof tracker.latitude === 'number' && typeof tracker.longitude === 'number') {
                    addDepotListItem(tracker);
                }
            });

            // Ajouter les beacons
            Object.values(beacons).forEach(beacon => {
                if (typeof beacon.latitude === 'number' && typeof beacon.longitude === 'number') {
                    addDepotListItem(beacon, true);
                }
            });

            // Vérifier si aucun élément
            if (depotList.children.length === 0) {
                const noTrackersItem = document.createElement('li');
                noTrackersItem.textContent = "Aucun tracker ni beacon dans un rayon de 200m.";
                depotList.appendChild(noTrackersItem);
            }
        }

        // Autres fonctions (setupToggleButtons, setupMapSwitch, displaySuggestions, setupSearch, setupRouteButton, etc.)
        // ... (Conservez vos fonctions existantes) ...

        // Fonction pour initialiser la carte
        function initializeMap() {
            mapboxgl.accessToken = MAPBOX_API_KEY;

            map = new mapboxgl.Map({
                container: 'map',
                style: 'mapbox://styles/mapbox/streets-v11',
                center: depotCoordinates,
                zoom: 14
            });

            map.addControl(new mapboxgl.NavigationControl(), 'top-right');

            // Initialiser les écouteurs
            setupMapClickListener();
            setupToggleButtons();
            setupMapSwitch();
            setupSearch();
            setupRouteButton();

            // Afficher les éléments de l'interface
            document.getElementById('search-container').style.display = 'flex';
            document.getElementById('toggle-controls').style.display = 'flex';
            document.getElementById('toggle-depot').style.display = 'flex';
            document.getElementById('map-switch-container').style.display = 'flex';

            // Récupérer et afficher les données des trackers
            getTrackersData();

            // Mettre à jour périodiquement les positions
            updateIntervalId = setInterval(getTrackersData, UPDATE_INTERVAL);
        }

        // Gestion du formulaire de connexion
        document.getElementById('credentials-form').addEventListener('submit', (event) => {
            event.preventDefault();
            
            const mapboxKeyInput = document.getElementById('mapbox-key').value.trim();
            const traccarUsername = document.getElementById('traccar-username').value.trim();
            const traccarPassword = document.getElementById('traccar-password').value.trim();

            if (!mapboxKeyInput || !traccarUsername || !traccarPassword) {
                alert('Veuillez remplir tous les champs.');
                return;
            }

            MAPBOX_API_KEY = mapboxKeyInput;
            TRACCAR_AUTH = btoa(`${traccarUsername}:${traccarPassword}`);

            document.getElementById('credentials-modal').style.display = 'none';

            initializeMap();
        });

        // Fonction pour arrêter la mise à jour des positions
        function stopUpdatingPositions() {
            if (updateIntervalId) {
                clearInterval(updateIntervalId);
                updateIntervalId = null;
            }
        }

        window.addEventListener('beforeunload', () => {
            stopUpdatingPositions();
        });
    </script>
</body>
</html>
